{"version":3,"sources":["../src/textlint-rule-ja-no-weak-phrase.js"],"names":["tokenize","require","dictionaryList","createMatcher","matchAll","module","exports","context","Syntax","RuleError","report","getSource","Str","node","text","then","currentTokens","matchResults","forEach","matchResult","firstToken","tokens","lastToken","length","firstWordIndex","Math","max","word_position","message","dict","index"],"mappings":"AAAA;AACA;;AACA,IAAMA,QAAQ,GAAGC,OAAO,CAAC,WAAD,CAAP,CAAqBD,QAAtC;;AACA,IAAME,cAAc,GAAGD,OAAO,CAAC,QAAD,CAA9B;;AACA,IAAM;AAAEE,EAAAA;AAAF,IAAoBF,OAAO,CAAC,oBAAD,CAAjC;;AACA,IAAMG,QAAQ,GAAGD,aAAa,CAACD,cAAD,CAA9B;;AACAG,MAAM,CAACC,OAAP,GAAiB,UAAUC,OAAV,EAAmB;AAChC,MAAM;AAAEC,IAAAA,MAAF;AAAUC,IAAAA,SAAV;AAAqBC,IAAAA,MAArB;AAA6BC,IAAAA;AAA7B,MAA2CJ,OAAjD;AACA,SAAO;AACH,KAACC,MAAM,CAACI,GAAR,EAAaC,IAAb,EAAmB;AACf,UAAMC,IAAI,GAAGH,SAAS,CAACE,IAAD,CAAtB;AACA,aAAOb,QAAQ,CAACc,IAAD,CAAR,CAAeC,IAAf,CAAoBC,aAAa,IAAI;AACxC;;;AAGA,YAAMC,YAAY,GAAGb,QAAQ,CAACY,aAAD,CAA7B;AACAC,QAAAA,YAAY,CAACC,OAAb,CAAqBC,WAAW,IAAI;AAChC,cAAMC,UAAU,GAAGD,WAAW,CAACE,MAAZ,CAAmB,CAAnB,CAAnB;AACA,cAAMC,SAAS,GAAGH,WAAW,CAACE,MAAZ,CAAmBF,WAAW,CAACE,MAAZ,CAAmBE,MAAnB,GAA4B,CAA/C,CAAlB;AACA,cAAMC,cAAc,GAAGC,IAAI,CAACC,GAAL,CAASN,UAAU,CAACO,aAAX,GAA2B,CAApC,EAAuC,CAAvC,CAAvB,CAHgC,CAIhC;;AACA,cAAMC,OAAO,GAAGT,WAAW,CAACU,IAAZ,CAAiBD,OAAjC;AACAlB,UAAAA,MAAM,CAACG,IAAD,EAAO,IAAIJ,SAAJ,CAAcmB,OAAd,EAAuB;AAChCE,YAAAA,KAAK,EAAEN;AADyB,WAAvB,CAAP,CAAN;AAGH,SATD;AAUH,OAfM,CAAP;AAgBH;;AAnBE,GAAP;AAqBH,CAvBD","sourcesContent":["// LICENSE : MIT\n\"use strict\";\nconst tokenize = require(\"kuromojin\").tokenize;\nconst dictionaryList = require(\"./dict\");\nconst { createMatcher } = require(\"morpheme-match-all\");\nconst matchAll = createMatcher(dictionaryList);\nmodule.exports = function (context) {\n    const { Syntax, RuleError, report, getSource } = context;\n    return {\n        [Syntax.Str](node) {\n            const text = getSource(node);\n            return tokenize(text).then(currentTokens => {\n                /**\n                 * @type {MatchResult[]}\n                 */\n                const matchResults = matchAll(currentTokens);\n                matchResults.forEach(matchResult => {\n                    const firstToken = matchResult.tokens[0];\n                    const lastToken = matchResult.tokens[matchResult.tokens.length - 1];\n                    const firstWordIndex = Math.max(firstToken.word_position - 1, 0);\n                    // replace $1\n                    const message = matchResult.dict.message;\n                    report(node, new RuleError(message, {\n                        index: firstWordIndex\n                    }));\n                });\n            });\n        }\n    }\n};\n"],"file":"textlint-rule-ja-no-weak-phrase.js"}